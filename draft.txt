cp node_modules/pdfjs-dist/build/pdf.worker.min.js public/pdf.worker.min.js


  // const openPDFDatabase = async (): Promise<IDBDatabase> => {
  //   return new Promise((resolve, reject) => {
  //     const request = indexedDB.open("PDFStorage", 1);
  //     request.onupgradeneeded = () => {
  //       const db = request.result;
  //       if (!db.objectStoreNames.contains("files")) {
  //         db.createObjectStore("files");
  //       }
  //     };
  //     request.onsuccess = () => resolve(request.result);
  //     request.onerror = () => reject(request.error);
  //   });
  // };

  // const savePDFToDB = async (key: string, bytes: Uint8Array) => {
  //   const db = await openPDFDatabase();
  //   const tx = db.transaction("files", "readwrite");
  //   tx.objectStore("files").put(bytes, key);
  //   return new Promise<void>((resolve, reject) => {
  //     tx.oncomplete = () => resolve();
  //     tx.onerror = () => reject(tx.error);
  //   });
  // };

  // const loadPDFFromDB = async (key: string): Promise<Uint8Array | null> => {
  //   const db = await openPDFDatabase();
  //   const tx = db.transaction("files", "readonly");
  //   const request = tx.objectStore("files").get(key);
  //   return new Promise((resolve, reject) => {
  //     request.onsuccess = () => {
  //       const result = request.result;
  //       if (result instanceof Uint8Array) return resolve(result);
  //       if (result instanceof ArrayBuffer)
  //         return resolve(new Uint8Array(result));
  //       if (result instanceof Blob) {
  //         result.arrayBuffer().then((buf) => resolve(new Uint8Array(buf)));
  //       } else resolve(null);
  //     };
  //     request.onerror = () => reject(request.error);
  //   });
  // };

  // const wrapText = (
  //   ctx: CanvasRenderingContext2D,
  //   text: string,
  //   x: number,
  //   y: number,
  //   maxWidth: number,
  //   lineHeight: number
  // ) => {
  //   const words = text.split(" ");
  //   let line = "";
  //   for (let n = 0; n < words.length; n++) {
  //     const testLine = line + words[n] + " ";
  //     const metrics = ctx.measureText(testLine);
  //     const testWidth = metrics.width;
  //     if (testWidth > maxWidth && n > 0) {
  //       ctx.fillText(line, x, y);
  //       line = words[n] + " ";
  //       y += lineHeight;
  //     } else {
  //       line = testLine;
  //     }
  //   }
  //   ctx.fillText(line, x, y);
  // };

// const renderPage = async (n: number) => {
  //   if (isRendering.current || !pdfDoc) return;
  //   isRendering.current = true;

  //   const page = await pdfDoc.getPage(n);
  //   const viewport = page.getViewport({ scale });
  //   const canvas = canvasRef.current!;
  //   const ctx = canvas.getContext("2d")!;
  //   canvas.width = viewport.width;
  //   canvas.height = viewport.height;

  //   await page.render({ canvasContext: ctx, viewport }).promise;

  //   ctx.font = "16px sans-serif";
  //   ctx.fillStyle = "black";
  //   ctx.textBaseline = "top";

  //   textItems
  //     .filter((t) => t.page === n)
  //     .forEach((item) => {
  //       wrapText(ctx, item.text, item.canvasX, item.canvasY, 300, 20);
  //     });

  //   setPageNum(n);
  //   isRendering.current = false;
  // };

  // const loadPDF = () => {
  //   const file = fileRef.current?.files?.[0];
  //   if (!file) return alert("Выберите PDF-файл");

  //   const reader = new FileReader();
  //   reader.onload = async () => {
  //     const bytes = new Uint8Array(reader.result as ArrayBuffer);
  //     await savePDFToDB("pdfRaw", bytes);

  //     const doc = await pdfjsLib.getDocument({ data: bytes }).promise;
  //     setPdfDoc(doc);
  //     setPageCount(doc.numPages);
  //     renderPage(1);
  //   };
  //   reader.readAsArrayBuffer(file);
  // };

  // const handleCanvasClick = (e: React.MouseEvent) => {
  //   const canvas = canvasRef.current!;
  //   const rect = canvas.getBoundingClientRect();
  //   const canvasX = ((e.clientX - rect.left) * canvas.width) / rect.width;
  //   const canvasY = ((e.clientY - rect.top) * canvas.height) / rect.height;

  //   const text = textRef.current?.value.trim();
  //   if (!text) return;

  //   const newItem = { text, page: pageNum, canvasX, canvasY };
  //   const newItems = [...textItems, newItem];
  //   setTextItems(newItems);
  //   localStorage.setItem("textItems", JSON.stringify(newItems));
  //   renderPage(pageNum);
  // };

  // const savePdf = async () => {
  //   const pdfBytes = await loadPDFFromDB("pdfRaw");
  //   if (!pdfBytes || textItems.length === 0)
  //     return alert("Нет данных для сохранения");

  //   const doc = await PDFDocument.load(pdfBytes);
  //   doc.registerFontkit(fontkit);

  //   const fontBytes = await fetch(
  //     "https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37/ttf/DejaVuSans.ttf"
  //   ).then((r) => r.arrayBuffer());
  //   const font = await doc.embedFont(fontBytes);
  //   const pages = doc.getPages();

  //   for (const item of textItems) {
  //     const page = pages[item.page - 1];
  //     const { width, height } = page.getSize();
  //     const scaleX = width / canvasRef.current!.width;
  //     const scaleY = height / canvasRef.current!.height;

  //     let pdfX = item.canvasX * scaleX;
  //     let pdfY = height - item.canvasY * scaleY;

  //     const maxWidth = 300;
  //     const lineHeight = 16;
  //     const words = item.text.split(" ");
  //     let line = "";

  //     for (let i = 0; i < words.length; i++) {
  //       const testLine = line + words[i] + " ";
  //       const testWidth = font.widthOfTextAtSize(testLine, 16);
  //       if (testWidth > maxWidth && i > 0) {
  //         page.drawText(line.trim(), {
  //           x: pdfX,
  //           y: pdfY,
  //           size: 11,
  //           font,
  //           color: rgb(0, 0, 0),
  //         });
  //         line = words[i] + " ";
  //         pdfY -= lineHeight;
  //       } else {
  //         line = testLine;
  //       }
  //     }

  //     if (line.trim()) {
  //       page.drawText(line.trim(), {
  //         x: pdfX,
  //         y: pdfY,
  //         size: 11,
  //         font,
  //         color: rgb(0, 0, 0),
  //       });
  //     }
  //   }

  //   const safeBuffer = new ArrayBuffer(pdfBytes.length);
  //   const safeBytes = new Uint8Array(safeBuffer);
  //   safeBytes.set(pdfBytes);

  //   const blob = new Blob([safeBytes], { type: "application/pdf" });
  //   const link = document.createElement("a");
  //   link.href = URL.createObjectURL(blob);
  //   link.download = "annotated.pdf";
  //   link.click();
  //   setTimeout(() => URL.revokeObjectURL(link.href), 1500);
  // };


***********************************PdfEditor******************************************************************
// "use client";
// import React, { useRef, useEffect, useState } from "react";
// import * as pdfjsLib from "pdfjs-dist";
// import { Button, Flex, Input } from "@chakra-ui/react";
// import pdfUtils from "../../utils/pdfUtils";

// pdfjsLib.GlobalWorkerOptions.workerSrc =
//   "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.worker.min.js";

// const PdfEditor = () => {
//   const canvasRef = useRef<HTMLCanvasElement>(null);
//   const fileRef = useRef<HTMLInputElement>(null);
//   const textRef = useRef<HTMLTextAreaElement>(null);
//   const [pdfDoc, setPdfDoc] = useState<any>(null);
//   const [pageNum, setPageNum] = useState(1);
//   const [pageCount, setPageCount] = useState(0);
//   const [textItems, setTextItems] = useState<any[]>([]);
//   const [scale, setScale] = useState(1.2);
//   const isRendering = useRef(false);
//   const initialRenderDone = useRef(false);

//   const {
//     openPDFDatabase,
//     savePDFToDB,
//     loadPDFFromDB,
//     wrapText,
//     renderPage,
//     loadPDF,
//     handleCanvasClick,
//     savePdf,
//   } = pdfUtils;

//   useEffect(() => {
//     const loadInitialData = async () => {
//       const pdfBytes = await loadPDFFromDB("pdfRaw");
//       if (!pdfBytes) return;

//       const doc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
//       setPdfDoc(doc);
//       setPageCount(doc.numPages);

//       const savedText = localStorage.getItem("textItems");
//       if (savedText) {
//         const parsed = JSON.parse(savedText);
//         setTextItems(parsed);
//       }

//       const savedPageNum = localStorage.getItem("lastPageNum");
//       if (savedPageNum) {
//         setPageNum(parseInt(savedPageNum));
//       }
//     };

//     loadInitialData();
//   }, []);

//   useEffect(() => {
//     if (
//       pdfDoc &&
//       canvasRef.current &&
//       !initialRenderDone.current &&
//       textItems.length >= 0
//     ) {
//       initialRenderDone.current = true;
//       renderPage(pageNum);
//     }
//   }, [pdfDoc, textItems]);

//   return (
//     <Flex>
//       <Input
//         ref={fileRef}
//         type="file"
//         accept="application/pdf"
//         width={"fit-content"}
//       />
//       <Button colorPalette="cyan" variant="surface" onClick={loadPDF}>
//         📂 Показать PDF
//       </Button>
//       <canvas
//         ref={canvasRef}
//         onClick={handleCanvasClick}
//         style={{
//           border: "1px solid #ccc",
//           margin: "1rem auto",
//           display: "block",
//           cursor: "crosshair",
//         }}
//       />
//       <div>
//         <Button
//           variant="outline"
//           onClick={() => {
//             const newPage = Math.max(1, pageNum - 1);
//             setPageNum(newPage);
//             localStorage.setItem("lastPageNum", String(newPage));
//           }}
//         >
//           ⬅
//         </Button>
//         <Button
//           variant="outline"
//           onClick={() => {
//             const newPage = Math.min(pageCount, pageNum + 1);
//             setPageNum(newPage);
//             localStorage.setItem("lastPageNum", String(newPage));
//           }}
//         >
//           ➡
//         </Button>

//         <Button
//           variant="outline"
//           onClick={() => setScale((s) => Math.min(s + 0.2, 3))}
//         >
//           🔍+
//         </Button>
//         <Button
//           variant="outline"
//           onClick={() => setScale((s) => Math.max(s - 0.2, 0.4))}
//         >
//           🔎–
//         </Button>
//         <Button variant="surface" colorPalette="cyan" onClick={savePdf}>
//           💾 Сохранить PDF
//         </Button>
//       </div>

//       <div>
//         <textarea
//           ref={textRef}
//           rows={3}
//           cols={30}
//           placeholder="✏️ Введите текст…"
//         />
//       </div>

//       <div>
//         <p>
//           Страница: {pageNum} / {pageCount}
//         </p>
//       </div>
//     </Flex>
//   );
// };

// export default PdfEditor;



// useEffect(() => {
  //   const loadInitialData = async () => {
  //     if (!uid || !fileRef.current) return;
  //     const pdfBytes = await loadPDFFromDB(key);
  //     if (!pdfBytes) return;

  //     const doc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
  //     setPdfDoc(doc);
  //     setPageCount(doc.numPages);

  //     const savedText = localStorage.getItem(getKey("textItems"));
  //     if (savedText) {
  //       const parsed = JSON.parse(savedText);
  //       setTextItems(parsed);
  //     }

  //     const savedPageNum = localStorage.getItem(getKey("lastPageNum"));
  //     if (savedPageNum) {
  //       setPageNum(parseInt(savedPageNum));
  //     }
  //   };

  //   loadInitialData();
  // }, []);




  useEffect(() => {
    if (
      pdfDoc &&
      canvasRef.current &&
      !initialRenderDone.current &&
      textItems.length >= 0
    ) {
      initialRenderDone.current = true;
      renderPageWithParams(pageNum);
    }
  }, [pdfDoc, textItems]);

  useEffect(() => {
    if (pdfDoc && canvasRef.current && initialRenderDone.current) {
      renderPageWithParams(pageNum);
    }
  }, [pageNum, scale]);

  useEffect(() => {
    if (pdfDoc && canvasRef.current) {
      renderPageWithParams(pageNum);
    }
  }, [textItems]);



const wrapText = (
  ctx: CanvasRenderingContext2D,
  text: string,
  x: number,
  y: number,
  maxWidth: number,
  lineHeight: number
) => {
  if (typeof window !== "undefined") {
    const words = text.split(" ");
    let line = "";
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + " ";
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line, x, y);
        line = words[n] + " ";
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, y);
  } else {
    throw new Error("Window is not defined");
  }
};

export const renderPage = async (
  pageNum: number,
  pdfDoc: any,
  canvasRef: React.RefObject<HTMLCanvasElement>,
  textItems: any[],
  scale: number,
  setPageNum: (n: number) => void,
  wrapTextFn: typeof wrapText,
  isRenderingRef: React.MutableRefObject<boolean>
) => {
  if (isRenderingRef.current || !pdfDoc) return;
  isRenderingRef.current = true;

  const page = await pdfDoc.getPage(pageNum);
  const viewport = page.getViewport({ scale });
  const canvas = canvasRef.current!;
  const ctx = canvas.getContext("2d")!;
  canvas.width = viewport.width;
  canvas.height = viewport.height;

  await page.render({ canvasContext: ctx, viewport }).promise;

  ctx.font = "16px sans-serif";
  ctx.fillStyle = "black";
  ctx.textBaseline = "top";

  textItems
    .filter((t) => t.page === pageNum)
    .forEach((item) => {
      const absX = item.relativeX * canvas.width;
      const absY = item.relativeY * canvas.height;
      wrapTextFn(ctx, item.text, absX, absY, 300, 20);
    });

  setPageNum(pageNum);
  isRenderingRef.current = false;
};



// import { TextItem } from "../types/types";
// import { useEffect, useRef } from "react";

// export function useCanvasDrag({
//   canvasRef,
//   textItems,
//   pageNum,
//   ctx,
//   onUpdate,
//   onRender,
// }: {
//   canvasRef: React.RefObject<HTMLCanvasElement>;
//   textItems: TextItem[];
//   pageNum: number;
//   ctx: CanvasRenderingContext2D;
//   onUpdate: (updatedItems: TextItem[]) => void;
//   onRender: () => void; 
// }) {
//   const draggingItemRef = useRef<TextItem | null>(null);
//   const offsetRef = useRef({ x: 0, y: 0 });
//   const scheduledRef = useRef(false);
//   const pendingItemsRef = useRef<TextItem[]>([]);

//   useEffect(() => {
//     const canvas = canvasRef.current;
//     if (!canvas || !ctx) return;

//     const getCoords = (clientX: number, clientY: number) => {
//       const rect = canvas.getBoundingClientRect();
//       return {
//         x: ((clientX - rect.left) * canvas.width) / rect.width,
//         y: ((clientY - rect.top) * canvas.height) / rect.height,
//       };
//     };

//     const checkHit = (x: number, y: number) => {
//       for (const item of textItems) {
//         if (item.page !== pageNum) continue;
//         const metrics = ctx.measureText(item.text);
//         const w = metrics.width;
//         const h = 20;
//         const itemX = item.relativeX * canvas.width;
//         const itemY = item.relativeY * canvas.height;

//         if (x >= itemX && x <= itemX + w && y >= itemY && y <= itemY + h) {
//           draggingItemRef.current = item;
//           offsetRef.current = {
//             x: x - itemX,
//             y: y - itemY,
//           };
//           if (navigator.vibrate) navigator.vibrate(50);
//           break;
//         }
//       }
//     };

//     const scheduleUpdate = () => {
//       if (!scheduledRef.current) {
//         scheduledRef.current = true;
//         requestAnimationFrame(() => {
//           onUpdate([...pendingItemsRef.current]);
//           scheduledRef.current = false;
//         });
//       }
//     };

//     const handleStart = (x: number, y: number) => checkHit(x, y);

//     const handleMove = (x: number, y: number) => {
//       const item = draggingItemRef.current;
//       if (!item) return;
//       item.relativeX = (x - offsetRef.current.x) / canvas.width;
//       item.relativeY = (y - offsetRef.current.y) / canvas.height;
//       pendingItemsRef.current = [...textItems];
//       scheduleUpdate();
//     };

//     const handleEnd = () => {
//       draggingItemRef.current = null;
//       onUpdate([...textItems]); // финальное обновление данных
//       onRender(); // отрисовка страницы
//     };

//     // Touch and Mouse handlers
//     const touchStart = (e: TouchEvent) => {
//       const { x, y } = getCoords(e.touches[0].clientX, e.touches[0].clientY);
//       handleStart(x, y);
//     };

//     const touchMove = (e: TouchEvent) => {
//       if (!draggingItemRef.current) return;
//       e.preventDefault();
//       const { x, y } = getCoords(e.touches[0].clientX, e.touches[0].clientY);
//       handleMove(x, y);
//     };

//     const mouseDown = (e: MouseEvent) => {
//       const { x, y } = getCoords(e.clientX, e.clientY);
//       handleStart(x, y);
//     };

//     const mouseMove = (e: MouseEvent) => {
//       if (!draggingItemRef.current) return;
//       const { x, y } = getCoords(e.clientX, e.clientY);
//       handleMove(x, y);
//     };

//     const removeListeners = () => {
//       canvas.removeEventListener("touchstart", touchStart);
//       canvas.removeEventListener("touchmove", touchMove);
//       canvas.removeEventListener("touchend", handleEnd);
//       canvas.removeEventListener("mousedown", mouseDown);
//       canvas.removeEventListener("mousemove", mouseMove);
//       canvas.removeEventListener("mouseup", handleEnd);
//     };

//     canvas.addEventListener("touchstart", touchStart);
//     canvas.addEventListener("touchmove", touchMove, { passive: false });
//     canvas.addEventListener("touchend", handleEnd);
//     canvas.addEventListener("mousedown", mouseDown);
//     canvas.addEventListener("mousemove", mouseMove);
//     canvas.addEventListener("mouseup", handleEnd);

//     return removeListeners;
//   }, [canvasRef, textItems, pageNum, ctx, onUpdate, onRender]);
// }




// export const handleCanvasClick = (
//   e: React.MouseEvent,
//   key: string,
//   canvasRef: React.RefObject<HTMLCanvasElement>,
//   textRef: React.RefObject<HTMLTextAreaElement>,
//   pageNum: number,
//   textItems: any[],
//   setTextItems: (items: any[]) => void,
//   renderPageFn: (updatedItems: any[]) => void
// ) => {
//   const canvas = canvasRef.current!;
//   const rect = canvas.getBoundingClientRect();
//   const canvasX = ((e.clientX - rect.left) * canvas.width) / rect.width;
//   const canvasY = ((e.clientY - rect.top) * canvas.height) / rect.height;

//   const relativeX = canvasX / canvas.width;
//   const relativeY = canvasY / canvas.height;

//   const text = textRef.current?.value.trim();
//   if (!text) return;

//   const newItem = { text, page: pageNum, relativeX, relativeY };
//   const newItems = [...textItems, newItem];
//   setTextItems(newItems);
//   localStorage.setItem(key, JSON.stringify(newItems));

//   renderPageFn(newItems);
// };
