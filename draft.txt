cp node_modules/pdfjs-dist/build/pdf.worker.min.js public/pdf.worker.min.js


  // const openPDFDatabase = async (): Promise<IDBDatabase> => {
  //   return new Promise((resolve, reject) => {
  //     const request = indexedDB.open("PDFStorage", 1);
  //     request.onupgradeneeded = () => {
  //       const db = request.result;
  //       if (!db.objectStoreNames.contains("files")) {
  //         db.createObjectStore("files");
  //       }
  //     };
  //     request.onsuccess = () => resolve(request.result);
  //     request.onerror = () => reject(request.error);
  //   });
  // };

  // const savePDFToDB = async (key: string, bytes: Uint8Array) => {
  //   const db = await openPDFDatabase();
  //   const tx = db.transaction("files", "readwrite");
  //   tx.objectStore("files").put(bytes, key);
  //   return new Promise<void>((resolve, reject) => {
  //     tx.oncomplete = () => resolve();
  //     tx.onerror = () => reject(tx.error);
  //   });
  // };

  // const loadPDFFromDB = async (key: string): Promise<Uint8Array | null> => {
  //   const db = await openPDFDatabase();
  //   const tx = db.transaction("files", "readonly");
  //   const request = tx.objectStore("files").get(key);
  //   return new Promise((resolve, reject) => {
  //     request.onsuccess = () => {
  //       const result = request.result;
  //       if (result instanceof Uint8Array) return resolve(result);
  //       if (result instanceof ArrayBuffer)
  //         return resolve(new Uint8Array(result));
  //       if (result instanceof Blob) {
  //         result.arrayBuffer().then((buf) => resolve(new Uint8Array(buf)));
  //       } else resolve(null);
  //     };
  //     request.onerror = () => reject(request.error);
  //   });
  // };

  // const wrapText = (
  //   ctx: CanvasRenderingContext2D,
  //   text: string,
  //   x: number,
  //   y: number,
  //   maxWidth: number,
  //   lineHeight: number
  // ) => {
  //   const words = text.split(" ");
  //   let line = "";
  //   for (let n = 0; n < words.length; n++) {
  //     const testLine = line + words[n] + " ";
  //     const metrics = ctx.measureText(testLine);
  //     const testWidth = metrics.width;
  //     if (testWidth > maxWidth && n > 0) {
  //       ctx.fillText(line, x, y);
  //       line = words[n] + " ";
  //       y += lineHeight;
  //     } else {
  //       line = testLine;
  //     }
  //   }
  //   ctx.fillText(line, x, y);
  // };

// const renderPage = async (n: number) => {
  //   if (isRendering.current || !pdfDoc) return;
  //   isRendering.current = true;

  //   const page = await pdfDoc.getPage(n);
  //   const viewport = page.getViewport({ scale });
  //   const canvas = canvasRef.current!;
  //   const ctx = canvas.getContext("2d")!;
  //   canvas.width = viewport.width;
  //   canvas.height = viewport.height;

  //   await page.render({ canvasContext: ctx, viewport }).promise;

  //   ctx.font = "16px sans-serif";
  //   ctx.fillStyle = "black";
  //   ctx.textBaseline = "top";

  //   textItems
  //     .filter((t) => t.page === n)
  //     .forEach((item) => {
  //       wrapText(ctx, item.text, item.canvasX, item.canvasY, 300, 20);
  //     });

  //   setPageNum(n);
  //   isRendering.current = false;
  // };

  // const loadPDF = () => {
  //   const file = fileRef.current?.files?.[0];
  //   if (!file) return alert("Выберите PDF-файл");

  //   const reader = new FileReader();
  //   reader.onload = async () => {
  //     const bytes = new Uint8Array(reader.result as ArrayBuffer);
  //     await savePDFToDB("pdfRaw", bytes);

  //     const doc = await pdfjsLib.getDocument({ data: bytes }).promise;
  //     setPdfDoc(doc);
  //     setPageCount(doc.numPages);
  //     renderPage(1);
  //   };
  //   reader.readAsArrayBuffer(file);
  // };

  // const handleCanvasClick = (e: React.MouseEvent) => {
  //   const canvas = canvasRef.current!;
  //   const rect = canvas.getBoundingClientRect();
  //   const canvasX = ((e.clientX - rect.left) * canvas.width) / rect.width;
  //   const canvasY = ((e.clientY - rect.top) * canvas.height) / rect.height;

  //   const text = textRef.current?.value.trim();
  //   if (!text) return;

  //   const newItem = { text, page: pageNum, canvasX, canvasY };
  //   const newItems = [...textItems, newItem];
  //   setTextItems(newItems);
  //   localStorage.setItem("textItems", JSON.stringify(newItems));
  //   renderPage(pageNum);
  // };

  // const savePdf = async () => {
  //   const pdfBytes = await loadPDFFromDB("pdfRaw");
  //   if (!pdfBytes || textItems.length === 0)
  //     return alert("Нет данных для сохранения");

  //   const doc = await PDFDocument.load(pdfBytes);
  //   doc.registerFontkit(fontkit);

  //   const fontBytes = await fetch(
  //     "https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37/ttf/DejaVuSans.ttf"
  //   ).then((r) => r.arrayBuffer());
  //   const font = await doc.embedFont(fontBytes);
  //   const pages = doc.getPages();

  //   for (const item of textItems) {
  //     const page = pages[item.page - 1];
  //     const { width, height } = page.getSize();
  //     const scaleX = width / canvasRef.current!.width;
  //     const scaleY = height / canvasRef.current!.height;

  //     let pdfX = item.canvasX * scaleX;
  //     let pdfY = height - item.canvasY * scaleY;

  //     const maxWidth = 300;
  //     const lineHeight = 16;
  //     const words = item.text.split(" ");
  //     let line = "";

  //     for (let i = 0; i < words.length; i++) {
  //       const testLine = line + words[i] + " ";
  //       const testWidth = font.widthOfTextAtSize(testLine, 16);
  //       if (testWidth > maxWidth && i > 0) {
  //         page.drawText(line.trim(), {
  //           x: pdfX,
  //           y: pdfY,
  //           size: 11,
  //           font,
  //           color: rgb(0, 0, 0),
  //         });
  //         line = words[i] + " ";
  //         pdfY -= lineHeight;
  //       } else {
  //         line = testLine;
  //       }
  //     }

  //     if (line.trim()) {
  //       page.drawText(line.trim(), {
  //         x: pdfX,
  //         y: pdfY,
  //         size: 11,
  //         font,
  //         color: rgb(0, 0, 0),
  //       });
  //     }
  //   }

  //   const safeBuffer = new ArrayBuffer(pdfBytes.length);
  //   const safeBytes = new Uint8Array(safeBuffer);
  //   safeBytes.set(pdfBytes);

  //   const blob = new Blob([safeBytes], { type: "application/pdf" });
  //   const link = document.createElement("a");
  //   link.href = URL.createObjectURL(blob);
  //   link.download = "annotated.pdf";
  //   link.click();
  //   setTimeout(() => URL.revokeObjectURL(link.href), 1500);
  // };


***********************************PdfEditor******************************************************************
// "use client";
// import React, { useRef, useEffect, useState } from "react";
// import * as pdfjsLib from "pdfjs-dist";
// import { Button, Flex, Input } from "@chakra-ui/react";
// import pdfUtils from "../../utils/pdfUtils";

// pdfjsLib.GlobalWorkerOptions.workerSrc =
//   "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.worker.min.js";

// const PdfEditor = () => {
//   const canvasRef = useRef<HTMLCanvasElement>(null);
//   const fileRef = useRef<HTMLInputElement>(null);
//   const textRef = useRef<HTMLTextAreaElement>(null);
//   const [pdfDoc, setPdfDoc] = useState<any>(null);
//   const [pageNum, setPageNum] = useState(1);
//   const [pageCount, setPageCount] = useState(0);
//   const [textItems, setTextItems] = useState<any[]>([]);
//   const [scale, setScale] = useState(1.2);
//   const isRendering = useRef(false);
//   const initialRenderDone = useRef(false);

//   const {
//     openPDFDatabase,
//     savePDFToDB,
//     loadPDFFromDB,
//     wrapText,
//     renderPage,
//     loadPDF,
//     handleCanvasClick,
//     savePdf,
//   } = pdfUtils;

//   useEffect(() => {
//     const loadInitialData = async () => {
//       const pdfBytes = await loadPDFFromDB("pdfRaw");
//       if (!pdfBytes) return;

//       const doc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
//       setPdfDoc(doc);
//       setPageCount(doc.numPages);

//       const savedText = localStorage.getItem("textItems");
//       if (savedText) {
//         const parsed = JSON.parse(savedText);
//         setTextItems(parsed);
//       }

//       const savedPageNum = localStorage.getItem("lastPageNum");
//       if (savedPageNum) {
//         setPageNum(parseInt(savedPageNum));
//       }
//     };

//     loadInitialData();
//   }, []);

//   useEffect(() => {
//     if (
//       pdfDoc &&
//       canvasRef.current &&
//       !initialRenderDone.current &&
//       textItems.length >= 0
//     ) {
//       initialRenderDone.current = true;
//       renderPage(pageNum);
//     }
//   }, [pdfDoc, textItems]);

//   return (
//     <Flex>
//       <Input
//         ref={fileRef}
//         type="file"
//         accept="application/pdf"
//         width={"fit-content"}
//       />
//       <Button colorPalette="cyan" variant="surface" onClick={loadPDF}>
//         📂 Показать PDF
//       </Button>
//       <canvas
//         ref={canvasRef}
//         onClick={handleCanvasClick}
//         style={{
//           border: "1px solid #ccc",
//           margin: "1rem auto",
//           display: "block",
//           cursor: "crosshair",
//         }}
//       />
//       <div>
//         <Button
//           variant="outline"
//           onClick={() => {
//             const newPage = Math.max(1, pageNum - 1);
//             setPageNum(newPage);
//             localStorage.setItem("lastPageNum", String(newPage));
//           }}
//         >
//           ⬅
//         </Button>
//         <Button
//           variant="outline"
//           onClick={() => {
//             const newPage = Math.min(pageCount, pageNum + 1);
//             setPageNum(newPage);
//             localStorage.setItem("lastPageNum", String(newPage));
//           }}
//         >
//           ➡
//         </Button>

//         <Button
//           variant="outline"
//           onClick={() => setScale((s) => Math.min(s + 0.2, 3))}
//         >
//           🔍+
//         </Button>
//         <Button
//           variant="outline"
//           onClick={() => setScale((s) => Math.max(s - 0.2, 0.4))}
//         >
//           🔎–
//         </Button>
//         <Button variant="surface" colorPalette="cyan" onClick={savePdf}>
//           💾 Сохранить PDF
//         </Button>
//       </div>

//       <div>
//         <textarea
//           ref={textRef}
//           rows={3}
//           cols={30}
//           placeholder="✏️ Введите текст…"
//         />
//       </div>

//       <div>
//         <p>
//           Страница: {pageNum} / {pageCount}
//         </p>
//       </div>
//     </Flex>
//   );
// };

// export default PdfEditor;



// useEffect(() => {
  //   const loadInitialData = async () => {
  //     if (!uid || !fileRef.current) return;
  //     const pdfBytes = await loadPDFFromDB(key);
  //     if (!pdfBytes) return;

  //     const doc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
  //     setPdfDoc(doc);
  //     setPageCount(doc.numPages);

  //     const savedText = localStorage.getItem(getKey("textItems"));
  //     if (savedText) {
  //       const parsed = JSON.parse(savedText);
  //       setTextItems(parsed);
  //     }

  //     const savedPageNum = localStorage.getItem(getKey("lastPageNum"));
  //     if (savedPageNum) {
  //       setPageNum(parseInt(savedPageNum));
  //     }
  //   };

  //   loadInitialData();
  // }, []);